{"version":3,"names":[],"mappings":"","sources":["cMake.js"],"sourcesContent":["\"use strict\";\nlet splitargs = require(\"splitargs\");\nlet which = require(\"which\");\nlet Promise = require(\"bluebird\");\nlet fs = require(\"fs-extra\");\nlet path = require(\"path\");\nlet _ = require(\"lodash\");\nlet environment = require(\"./environment\");\nlet Dist = require(\"./dist\");\nlet CMLog = require(\"./cmLog\");\nlet vsDetect = require(\"./vsDetect\");\nlet TargetOptions = require(\"./targetOptions\");\nlet processHelpers = require(\"./processHelpers\");\nlet locateNAN = require(\"./locateNAN\");\nlet npmConfigData = require(\"rc\")(\"npm\");\nlet async = Promise.coroutine;\nlet Toolset = require(\"./toolset\");\n\nfunction CMake(options) {\n    this.options = options || {};\n    this.log = new CMLog(this.options);\n    this.dist = new Dist(this.options);\n    this.projectRoot = path.resolve(this.options.directory || process.cwd());\n    this.workDir = path.resolve(this.options.out || path.join(this.projectRoot, \"build\"));\n    this.config = this.options.debug ? \"Debug\" : \"Release\";\n    this.buildDir = path.join(this.workDir, this.config);\n    this._isAvailable = null;\n    this.targetOptions = new TargetOptions(this.options);\n    this.toolset = new Toolset(this.options);\n    this.cMakeOptions = this.options.cMakeOptions || {};\n    this.silent = !!options.silent;\n}\n\nObject.defineProperties(CMake.prototype, {\n    path: {\n        get: function () {\n            return this.options.cmakePath || \"cmake\";\n        }\n    },\n    isAvailable: {\n        get: function () {\n            if (this._isAvailable === null) {\n                this._isAvailable = CMake.isAvailable(this.options);\n            }\n            return this._isAvailable;\n        }\n    }\n});\n\nCMake.isAvailable = function (options) {\n    options = options || {};\n    try {\n        if (options.cmakePath) {\n            let stat = fs.lstatSync(options.cmakePath);\n            return !stat.isDirectory();\n        }\n        else {\n            which.sync(\"cmake\");\n            return true;\n        }\n    }\n    catch (e) {\n        _.noop(e);\n    }\n    return false;\n};\n\nCMake.getGenerators = async(function* (options) {\n    let arch = \" [arch]\";\n    options = options || {};\n    let gens = [];\n    if (CMake.isAvailable(options)) {\n        // try parsing machine-readable capabilities (available since CMake 3.7)\n        try {\n            let stdout = yield processHelpers.exec((options.cmakePath || \"cmake\") + \" -E capabilities\");\n            let capabilities = JSON.parse(stdout);\n            return capabilities.generators.map(x => x.name);\n        }\n        catch (error) {\n            this.log.verbose(\"TOOL\", \"Failed to query CMake capabilities (CMake is probably older than 3.7)\");\n        }\n\n        // fall back to parsing help text\n        let stdout = yield processHelpers.exec((options.cmakePath || \"cmake\") + \" --help\");\n        let hasCr = stdout.includes(\"\\r\\n\");\n        let output = hasCr ? stdout.split(\"\\r\\n\") : stdout.split(\"\\n\");\n        let on = false;\n        output.forEach(function (line, i) {\n            if (on) {\n                let parts = line.split(\"=\");\n                if ((parts.length === 2 && parts[0].trim()) ||\n                    (parts.length === 1 && i !== output.length - 1 && output[i + 1].trim()[0] === \"=\")) {\n                    let gen = parts[0].trim();\n                    if (_.endsWith(gen, arch)) {\n                        gen = gen.substr(0, gen.length - arch.length);\n                    }\n                    gens.push(gen);\n                }\n            }\n            if (line.trim() === \"Generators\") {\n                on = true;\n            }\n        });\n    }\n    else {\n        throw new Error(\"CMake is not installed. Install CMake.\");\n    }\n    return gens;\n});\n\nCMake.prototype.getGenerators = function () {\n    return CMake.getGenerators(this.options);\n};\n\nCMake.prototype.verifyIfAvailable = function () {\n    if (!this.isAvailable) {\n        throw new Error(\"CMake executable is not found. Please use your system's package manager to install it, or you can get installers from there: http://cmake.org.\");\n    }\n};\n\nCMake.prototype.getConfigureCommand = async(function* () {\n    // Create command:\n    let command = this.path;\n    command += \" \\\"\" + this.projectRoot + \"\\\" --no-warn-unused-cli\";\n\n    let D = [];\n\n    // CMake.js watermark\n    D.push({\"CMAKE_JS_VERSION\": environment.moduleVersion});\n\n    // Build configuration:\n    D.push({\"CMAKE_BUILD_TYPE\": this.config});\n    if (environment.isWin) {\n\t\tD.push({\"CMAKE_RUNTIME_OUTPUT_DIRECTORY\": this.workDir});\n\t}\n\telse {\n\t\tD.push({\"CMAKE_LIBRARY_OUTPUT_DIRECTORY\": this.buildDir});\n\t}\n\n    // Include and lib:\n    let incPaths;\n    if (this.dist.headerOnly) {\n        incPaths = [path.join(this.dist.internalPath, \"/include/node\")];\n    }\n    else {\n        let nodeH = path.join(this.dist.internalPath, \"/src\");\n        let v8H = path.join(this.dist.internalPath, \"/deps/v8/include\");\n        let uvH = path.join(this.dist.internalPath, \"/deps/uv/include\");\n        incPaths = [nodeH, v8H, uvH];\n    }\n\n    // NAN\n    let nanH = yield locateNAN(this.projectRoot);\n    if (nanH) {\n        incPaths.push(nanH);\n    }\n\n    // Includes:\n    D.push({\"CMAKE_JS_INC\": incPaths.join(\";\")});\n\n    // Sources:\n    let srcPaths = [];\n    if (environment.isWin) {\n        let delayHook = path.normalize(path.join(__dirname, '..', 'cpp', 'win_delay_load_hook.cc'));\n\n        srcPaths.push(delayHook.replace(/\\\\/gm, '/'));\n    }\n\n    D.push({\"CMAKE_JS_SRC\": srcPaths.join(\";\")});\n\n    // Runtime:\n    D.push({\"NODE_RUNTIME\": this.targetOptions.runtime});\n    D.push({\"NODE_RUNTIMEVERSION\": this.targetOptions.runtimeVersion});\n    D.push({\"NODE_ARCH\": this.targetOptions.arch});\n\n    if (environment.isWin) {\n        // Win\n        let libs = this.dist.winLibs;\n        if (libs.length) {\n            D.push({\"CMAKE_JS_LIB\": libs.join(\";\")});\n        }\n    }\n\n    // Custom options\n    for (let k of _.keys(this.cMakeOptions)) {\n        D.push({[k]: this.cMakeOptions[k]});\n    }\n\n    // Toolset:\n    yield this.toolset.initialize(false);\n\n    if (this.toolset.generator) {\n        command += \" -G\\\"\" + this.toolset.generator + \"\\\"\";\n    }\n    if (this.toolset.toolset) {\n        command += \" -T\\\"\" + this.toolset.toolset + \"\\\"\";\n    }\n    if (this.toolset.cppCompilerPath) {\n        D.push({\"CMAKE_CXX_COMPILER\": this.toolset.cppCompilerPath});\n    }\n    if (this.toolset.cCompilerPath) {\n        D.push({\"CMAKE_C_COMPILER\": this.toolset.cCompilerPath});\n    }\n    if (this.toolset.compilerFlags.length) {\n        D.push({\"CMAKE_CXX_FLAGS\": this.toolset.compilerFlags.join(\" \")});\n    }\n    if (this.toolset.linkerFlags.length) {\n        D.push({\"CMAKE_SHARED_LINKER_FLAGS\": this.toolset.linkerFlags.join(\" \")});\n    }\n    if (this.toolset.makePath) {\n        D.push({\"CMAKE_MAKE_PROGRAM\": this.toolset.makePath});\n    }\n\n    // Load NPM config\n    for (let key of _.keys(npmConfigData)) {\n        if (_.startsWith(key, \"cmake_\")) {\n            let s = {};\n            let sk = key.substr(6);\n            if (sk) {\n                s[sk] = npmConfigData[key];\n                if (s[sk]) {\n                    D.push(s);\n                }\n            }\n        }\n    }\n\n    command += \" \" +\n        D.map(function (p) {\n            return \"-D\" + _.keys(p)[0] + \"=\\\"\" + _.values(p)[0] + \"\\\"\";\n        }).join(\" \");\n\n    return command;\n});\n\nCMake.prototype.configure = async(function* () {\n    this.verifyIfAvailable();\n\n    this.log.info(\"CMD\", \"CONFIGURE\");\n    let listPath = path.join(this.projectRoot, \"CMakeLists.txt\");\n    let command = yield this.getConfigureCommand();\n\n    try {\n        yield fs.lstat(listPath);\n    }\n    catch (e) {\n        throw new Error(\"'\" + listPath + \"' not found.\");\n    }\n\n    try {\n        yield fs.ensureDir(this.workDir);\n    }\n    catch (e) {\n        _.noop(e);\n    }\n\n    let cwd = process.cwd();\n    process.chdir(this.workDir);\n    try {\n        yield this._run(command);\n    }\n    finally {\n        process.chdir(cwd);\n    }\n});\n\nCMake.prototype.ensureConfigured = async(function* () {\n    try {\n        yield fs.lstat(path.join(this.workDir, \"CMakeCache.txt\"));\n    }\n    catch (e) {\n        _.noop(e);\n        yield this.configure();\n    }\n});\n\nCMake.prototype.getBuildCommand = function() {\n    var command = this.path + \" --build \\\"\" + this.workDir + \"\\\" --config \" + this.config;\n    if (this.options.target) {\n        command += \" --target \" + this.options.target;\n    }\n    return Promise.resolve(command);\n};\n\nCMake.prototype.build = async(function* () {\n    this.verifyIfAvailable();\n\n    yield this.ensureConfigured();\n    let buildCommand = yield this.getBuildCommand();\n    this.log.info(\"CMD\", \"BUILD\");\n    yield this._run(buildCommand);\n});\n\nCMake.prototype.getCleanCommand = function () {\n    return this.path + \" -E remove_directory \\\"\" + this.workDir + \"\\\"\";\n};\n\nCMake.prototype.clean = function () {\n    this.verifyIfAvailable();\n\n    this.log.info(\"CMD\", \"CLEAN\");\n    return this._run(this.getCleanCommand());\n};\n\nCMake.prototype.reconfigure = async(function* () {\n    yield this.clean();\n    yield this.configure();\n});\n\nCMake.prototype.rebuild = async(function* () {\n    yield this.clean();\n    yield this.build();\n});\n\nCMake.prototype.compile = async(function* () {\n    try {\n        yield this.build();\n    }\n    catch (e) {\n        _.noop(e);\n        this.log.info(\"REP\", \"Build has been failed, trying to do a full rebuild.\");\n        yield this.rebuild();\n    }\n});\n\nCMake.prototype._run = function (command) {\n    this.log.info(\"RUN\", command);\n    return processHelpers.run(command, {silent: this.silent});\n};\n\nmodule.exports = CMake;\n"],"file":"cMake.js"}