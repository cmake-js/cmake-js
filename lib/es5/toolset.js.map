{"version":3,"names":[],"mappings":"","sources":["toolset.js"],"sourcesContent":["\"use strict\";\nlet Promise = require(\"bluebird\");\nlet async = Promise.coroutine;\nlet _ = require(\"lodash\");\nlet TargetOptions = require(\"./targetOptions\");\nlet environment = require(\"./environment\");\nlet assert = require(\"assert\");\nlet path = require(\"path\");\nlet CMLog = require(\"./cmLog\");\nlet processHelpers = require(\"./processHelpers\");\n\nfunction Toolset(options) {\n    this.options = options || {};\n    this.targetOptions = new TargetOptions(this.options);\n    this.generator = options.generator;\n    this.toolset = options.toolset;\n    this.target = options.target;\n    this.cCompilerPath = null;\n    this.cppCompilerPath = null;\n    this.compilerFlags = [];\n    this.linkerFlags = [];\n    this.makePath = null;\n    this.log = new CMLog(this.options);\n    this._initialized = false;\n}\n\nToolset.prototype.initialize = async(function*(install) {\n    if (!this._initialized) {\n        if (environment.isWin) {\n            yield this.initializeWin(install);\n        }\n        else {\n            this.initializePosix(install);\n        }\n        this._initialized = true;\n    }\n});\n\nToolset.prototype.initializePosix = function (install) {\n    // 1: Compiler\n    if (!environment.isGPPAvailable && !environment.isClangAvailable) {\n        if (environment.isOSX) {\n            throw new Error(\"C++ Compiler toolset is not available. Install Xcode Commandline Tools from Apple Dev Center, or install Clang with homebrew by invoking: 'brew install llvm --with-clang --with-asan'.\");\n        }\n        else {\n            throw new Error(\"C++ Compiler toolset is not available. Install proper compiler toolset with your package manager, eg. 'sudo apt-get install g++'.\");\n        }\n    }\n\n    if (this.options.preferClang && environment.isClangAvailable) {\n        if (install) {\n            this.log.info(\"TOOL\", \"Using clang++ compiler, because preferClang option is set, and clang++ is available.\");\n        }\n        this.cppCompilerPath = \"clang++\";\n        this.cCompilerPath = \"clang\";\n    }\n    else if (this.options.preferGnu && environment.isGPPAvailable) {\n        if (install) {\n            this.log.info(\"TOOL\", \"Using g++ compiler, because preferGnu option is set, and g++ is available.\");\n        }\n        this.cppCompilerPath = \"g++\";\n        this.cCompilerPath = \"gcc\";\n    }\n    // if it's already set because of options...\n    if (this.generator) {\n        if (install) {\n            this.log.info(\"TOOL\", \"Using \" + this.options.generator + \" generator, as specified from commandline.\");\n        }\n    }\n    // 2: Generator\n    else if (environment.isOSX) {\n        if (this.options.preferXcode) {\n            if (install) {\n                this.log.info(\"TOOL\", \"Using Xcode generator, because preferXcode option is set.\");\n            }\n            this.generator = \"Xcode\";\n        }\n        else if (this.options.preferMake && environment.isMakeAvailable) {\n            if (install) {\n                this.log.info(\"TOOL\", \"Using Unix Makefiles generator, because preferMake option is set, and make is available.\");\n            }\n            this.generator = \"Unix Makefiles\";\n        }\n        else if (environment.isNinjaAvailable) {\n            if (install) {\n                this.log.info(\"TOOL\", \"Using Ninja generator, because ninja is available.\");\n            }\n            this.generator = \"Ninja\";\n        }\n        else {\n            if (install) {\n                this.log.info(\"TOOL\", \"Using Unix Makefiles generator.\");\n            }\n            this.generator = \"Unix Makefiles\";\n        }\n    }\n    else {\n        if (this.options.preferMake && environment.isMakeAvailable) {\n            if (install) {\n                this.log.info(\"TOOL\", \"Using Unix Makefiles generator, because preferMake option is set, and make is available.\");\n            }\n            this.generator = \"Unix Makefiles\";\n        }\n        else if (environment.isNinjaAvailable) {\n            if (install) {\n                this.log.info(\"TOOL\", \"Using Ninja generator, because ninja is available.\");\n            }\n            this.generator = \"Ninja\";\n        }\n        else {\n            if (install) {\n                this.log.info(\"TOOL\", \"Using Unix Makefiles generator.\");\n            }\n            this.generator = \"Unix Makefiles\";\n        }\n    }\n\n    // 3: Flags\n    if (environment.isOSX) {\n        if (install) {\n            this.log.verbose(\"TOOL\", \"Setting default OSX compiler flags.\");\n        }\n\n        this.compilerFlags.push(\"-D_DARWIN_USE_64_BIT_INODE=1\");\n        this.compilerFlags.push(\"-D_LARGEFILE_SOURCE\");\n        this.compilerFlags.push(\"-D_FILE_OFFSET_BITS=64\");\n        this.compilerFlags.push(\"-DBUILDING_NODE_EXTENSION\");\n        this.linkerFlags.push(\"-undefined dynamic_lookup\");\n    }\n\n    // 4: Build target\n    if (this.options.target) {\n        this.log.info(\"TOOL\", \"Building only the \" + this.options.target + \" target, as specified from the command line.\");\n    }\n};\n\nToolset.prototype.initializeWin = async(function*(install) {\n    // Visual Studio:\n    // if it's already set because of options...\n    if (this.generator) {\n        if (install) {\n            this.log.info(\"TOOL\", \"Using \" + this.options.generator + \" generator, as specified from commandline.\");\n        }\n\n        this.linkerFlags.push(\"/DELAYLOAD:NODE.EXE\");\n\n        if (this.targetOptions.isX86) {\n            if (install) {\n                this.log.verbose(\"TOOL\", \"Setting SAFESEH:NO linker flag.\");\n            }\n            this.linkerFlags.push(\"/SAFESEH:NO\");\n        }\n        return;\n    }\n    let topVS = yield this._getTopSupportedVisualStudioGenerator();\n    //if (!this.options.noMSVC) {\n    if (topVS) {\n        if (install) {\n            this.log.info(\"TOOL\", `Using ${topVS} generator.`);\n        }\n        this.generator = topVS;\n\n        this.linkerFlags.push(\"/DELAYLOAD:NODE.EXE\");\n\n        if (this.targetOptions.isX86) {\n            if (install) {\n                this.log.verbose(\"TOOL\", \"Setting SAFESEH:NO linker flag.\");\n            }\n            this.linkerFlags.push(\"/SAFESEH:NO\");\n        }\n    }\n    else {\n        throw new Error(\"There is no Visual C++ compiler installed. Install Visual C++ Build Toolset or Visual Studio.\");\n    }\n});\n\nToolset.prototype._getTopSupportedVisualStudioGenerator = async(function*() {\n    assert(environment.isWin);\n\n    let programFilesPath = _.get(process.env, \"ProgramFiles(x86)\", _.get(process.env, \"ProgramFiles\"));\n    let vswhereCommand = path.resolve(programFilesPath, \"Microsoft Visual Studio\", \"Installer\", \"vswhere.exe\");\n    const vswhereOutput = yield processHelpers.exec(`\"${vswhereCommand}\" -property installationVersion`);\n    if (!vswhereOutput) {\n        return windowBuildToolsPackageGeneratorOrNull();\n    }\n\n    let version = vswhereOutput.trim();\n    version = version.substring(0, version.indexOf(\".\"));\n    const generator = {\n        \"14\": \"Visual Studio 14 2015\",\n        \"15\": \"Visual Studio 15 2017\",\n        \"16\": \"Visual Studio 16 2019\",\n    }[version];\n\n    if (!generator) {\n        return windowBuildToolsPackageGeneratorOrNull();\n    }\n\n    const cppBuildToolsOutput = yield processHelpers.exec(`\"${vswhereCommand}\" -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64`);\n    if (!cppBuildToolsOutput || cppBuildToolsOutput.indexOf(\"installationVersion: \" + version) === -1) {\n        return null;\n    }\n\n    return generator;\n});\n\nmodule.exports = Toolset;\n\nfunction windowBuildToolsPackageGeneratorOrNull() {\n    return hasGlobalPackage(\"windows-build-tools\") ? \"Visual Studio 15 2017\" : null;\n}\n\nfunction hasGlobalPackage(packageName) {\n    var childProcess = require('child_process');\n    var path = require('path');\n    var fs = require('fs');\n  \n    var globalNodeModules = childProcess.execSync('npm root -g').toString().trim();\n    var packageDir = path.join(globalNodeModules, packageName);\n    if (fs.existsSync(packageDir)) {\n        return true;\n    }\n    \n    packageDir = path.join(globalNodeModules, 'npm/node_modules', packageName); //find package required by old npm\n    return fs.existsSync(packageDir);\n}\n"],"file":"toolset.js"}